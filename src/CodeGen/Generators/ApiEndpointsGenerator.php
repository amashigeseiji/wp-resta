<?php
namespace Wp\Resta\CodeGen\Generators;

use Wp\Resta\CodeGen\OpenApiParser;

/**
 * API Endpoints型マップ生成
 */
class ApiEndpointsGenerator
{
    /**
     * API Endpoints型マップを生成
     *
     * @param OpenApiParser $parser
     * @return string 生成されたTypeScriptコード
     */
    public function generate(OpenApiParser $parser): string
    {
        $endpoints = $parser->extractEndpoints();

        $output = "// Auto-generated API endpoints type map from OpenAPI schema\n";
        $output .= "// Do not edit this file directly\n\n";

        // スキーマをインポート（必要に応じて）
        $output .= "import type * as Schema from './schema';\n\n";

        $output .= "export interface ApiEndpoints {\n";

        foreach ($endpoints as $endpoint) {
            $output .= $this->generateEndpointType($endpoint, $parser);
        }

        $output .= "}\n";

        return $output;
    }

    /**
     * 単一のエンドポイント型を生成
     *
     * @param array{path: string, method: string, pathParams: array<int, array{name: mixed, type: mixed, required: mixed, description: mixed}>, queryParams: array<int, array{name: mixed, type: mixed, required: mixed, description: mixed}>, responseSchema: mixed, description: mixed, tags: mixed} $endpoint
     * @param OpenApiParser $parser
     * @return string
     */
    private function generateEndpointType(array $endpoint, OpenApiParser $parser): string
    {
        $method = $endpoint['method'];
        $path = $endpoint['path'];
        $key = "{$method} {$path}";

        $paramsType = $this->generateParamsType($endpoint['pathParams'], $endpoint['queryParams'], $parser);
        $responseType = $this->generateResponseType($endpoint['responseSchema'], $parser);

        $output = '';

        // ドキュメンテーションコメント
        if (!empty($endpoint['description'])) {
            $output .= "  /**\n";
            $output .= "   * {$endpoint['description']}\n";
            if (!empty($endpoint['tags'])) {
                $output .= "   * @tags " . implode(', ', $endpoint['tags']) . "\n";
            }
            $output .= "   */\n";
        }

        $output .= "  '{$key}': {\n";
        $output .= "    params: {$paramsType};\n";
        $output .= "    response: {$responseType};\n";
        $output .= "  };\n\n";

        return $output;
    }

    /**
     * パラメータ型を生成
     *
     * @param array<int, array{name: mixed, type: mixed, required: mixed, description: mixed}> $pathParams
     * @param array<int, array{name: mixed, type: mixed, required: mixed, description: mixed}> $queryParams
     * @param OpenApiParser $parser
     * @return string
     */
    private function generateParamsType(array $pathParams, array $queryParams, OpenApiParser $parser): string
    {
        $allParams = array_merge($pathParams, $queryParams);

        if (empty($allParams)) {
            return '{}';
        }

        $props = [];

        foreach ($allParams as $param) {
            $name = $param['name'];
            $type = $this->convertParamType($param['type']);
            $required = $param['required'] ?? false;
            $optional = $required ? '' : '?';

            $props[] = "{$name}{$optional}: {$type}";
        }

        return '{ ' . implode('; ', $props) . ' }';
    }

    /**
     * レスポンス型を生成
     *
     * @param array<string, mixed>|null $responseSchema
     * @param OpenApiParser $parser
     * @return string
     */
    private function generateResponseType(?array $responseSchema, OpenApiParser $parser): string
    {
        if ($responseSchema === null) {
            return 'void';
        }

        // $ref参照の場合
        if (isset($responseSchema['$ref'])) {
            $schemaName = $parser->extractSchemaNameFromRef($responseSchema['$ref']);
            return "Schema.{$schemaName}";
        }

        // インラインスキーマの場合
        return $this->convertInlineSchema($responseSchema, $parser);
    }

    /**
     * パラメータ型をTypeScript型に変換
     *
     * @param string $type
     * @return string
     */
    private function convertParamType(string $type): string
    {
        return match ($type) {
            'integer' => 'number',
            'number' => 'number',
            'boolean' => 'boolean',
            'array' => 'any[]',
            'object' => 'Record<string, any>',
            default => 'string',
        };
    }

    /**
     * インラインスキーマをTypeScript型に変換
     *
     * @param array<string, mixed> $schema
     * @param OpenApiParser $parser
     * @return string
     */
    private function convertInlineSchema(array $schema, OpenApiParser $parser): string
    {
        $type = $schema['type'] ?? 'object';

        switch ($type) {
            case 'string':
                return 'string';
            case 'integer':
            case 'number':
                return 'number';
            case 'boolean':
                return 'boolean';
            case 'array':
                $items = $schema['items'] ?? ['type' => 'unknown'];
                if (isset($items['$ref'])) {
                    $schemaName = $parser->extractSchemaNameFromRef($items['$ref']);
                    return "Schema.{$schemaName}[]";
                }
                $itemType = $this->convertInlineSchema($items, $parser);
                return "{$itemType}[]";
            case 'object':
                if (isset($schema['properties'])) {
                    $props = [];
                    foreach ($schema['properties'] as $propName => $propSchema) {
                        $propType = $this->convertInlineSchema($propSchema, $parser);
                        $props[] = "{$propName}: {$propType}";
                    }
                    return '{ ' . implode('; ', $props) . ' }';
                }
                return 'Record<string, unknown>';
            default:
                return 'unknown';
        }
    }
}
